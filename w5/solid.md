# Принципы SOLID
___

## Single-responsibility
Пусть у нас есть какой-то проект, в котором надо соорудить довольно непростой интерфейс, где надо, чтобы некоторая структура объектов делала разные по своему типу задачи в этом проекте. Мы могли взять и создать класс, в котором сразу бы определили и реализовали способы выполнения всех этих задач, но это было бы плохой практикой, так как если обвалится какая-то часть этого класса, отвечающая за одну определенную задачу, то у нас обвалится сразу весь код, где используется этот класс. Таким образом, будет правильно сделать, что бы каждый класс отвечал за одну и только одну определенную задачу, так как это позволит тогда сделать код менее уязвимым к тотальному разрушению. Такую идею и несет данный SOLID-принцип.

## Open-close
Если кратко: программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации. Это означает, что если мы захотим что-то новое добавить в нашу программу, то по-хорошему для того чтобы все работало минимум также хорошо как раньше, нам не требуется для этого переписывать старый код, а достаточно только написать новый.

## Liskov-substitution
Опять же краткая формулировка: необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов. Фактически, пусть у нас есть суперкласс и есть какие-то подклассы. Правильно будет выделить в суперкласс все методы, являюищиеся общими для всех подклассов. Тогда, гипотетически, заменив где-то в коде исходный суперкласс на его подкласс, все должно работать, причем допускается, что результат от такой работы может измениться из-за, скажем, полиморфизма. 