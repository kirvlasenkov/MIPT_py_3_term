# Основные принципы ООП
---

## Объект
В языке **Python** принято говорить, что все является объектами. Фактически, объект - это самый-самый основной суперкласс над всеми другими классами, в то же время класс - это некоторый образ описания сущности, некоторой определенной группы объектов, обладающей схожими свойствами. Иногда также объектом называют конкретный экземпляр какого-то класса.

## Инкапсуляция
Этим термином обычно называют особый подход к устройству класса, когда, к примеру, методы и аттрибуты делят на публичные и приватные, с целью того, чтобы сделать код более безопасным, а также более удобным с точки зрения рефакторинга. То есть скажем, пусть в нашем классе некоторые аттрибуты объектоов, к которым мы бы не хотели, чтобы пользователь имел доступ. Тогда разумнее всего будет эти аттрибуты сделать приватными (в **Python** достаточно для этого прописать в названии поля два знака `_`),  уже делать все вещи с этим полем при помощи особых публичных методов (getter, setter, deletter), к которым пользователь уже имеет доступ.

## Наследование
Рассмотрим какой-то большой класс, так называемого *Большого Брата*. Этот класс явлвяется базисным для той структуры вещей, которую мы хотим реализовать, поэтому другие подклассы этой структуры очень хотели бы иметь такие же методы и поля, как и у *Большого Брата*, но при этом возможно они хотят добавить у себя какие-то новые методы, либо переопределить старые. Такой механизм как раз и реализует концепция наследования. Как плюс, помогает избегать рефакторинга.

## Полимофорфзим
Фактически, это наследование с модификациями. Такой принцип позволяет писать в программе один интерфейс, который применительно к разным типам объектов будут иметь разичную реализацию. Как я понимаю, обычно создается некоторый суперкласс, являющейся как раз-таки интерфейсом; в нем реализуются общие для подклассов методы и поля, причем их реализация обычно производится через методы, которые определены уже в нужном подклассе. Это все позволяет в итоге по-разному для разных подклассов определять методы из суперкласса. А это глобально помогает избегать того же самого рефакторинга